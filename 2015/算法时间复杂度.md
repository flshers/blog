# 算法时间复杂度

####量级
> 分析算法A 与 算法B

> 算法A: 100n+1   解决尺寸为n的问题
> 算法B: n*n+n+1  解决尺寸为n的问题

n为不同值的时候 算法AB的运行时间：
```
输入尺寸      算法A运行时间       算法B运行时间
10            1001                111
100           10001               10101
10000         100001              1001001
100000        1000001             >10的10次方
```
> n=10  算法B 优于 算法A
> n=100 算法A 优于 算法B
> n 更大的尺寸下  算法A 优于算法B







####时间复杂度定义
定义：如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)，它是n的某一函数T(n)称为这一算法的“时间复杂性”。
当输入量n逐渐加大时，时间复杂性的极限情形称为算法的“渐近时间复杂性”。
####大O表示法
“大O表示法" :在这种描述中使用的基本参数是n，即问题实例的规模，把复杂性或运行时间表达为n的函数。这里的“O”表示量级(order)

####算法的时间复杂度和空间复杂度都是用大O表示法。

>在n个随即数中查找某个数字，最好的情况是第一个数字就是，此时时间复杂度为O(1)，若最后一个数字才是我们要找的，那么时间复杂度是O(n)，这是最坏的情况。

####推导算法时间复杂度
```
1.用常数1取代运行时间中的所有加法常数。
2.在修改后的运行次数函数中，只保留最高阶项。
3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。 
```

####时间复杂度
**O(1)  常量级**
```
  example:
    sum = 0 ;n = 100    #执行一次
    sum = (1+n)*n/2     #执行一次
    print(sum)          #执行一次
这个算法的运行次数函数是f(n)=3。根据我们推导大O阶的方法，第一步就是把常数项3改为1。在保留最高阶项时发现，它根本没有最高阶项，所以这个算法的时间复杂度为O(1)。

  * 加法减法 都是O(1)
```
**O(log n) 对数级**
```
 example:
  二分搜索：1,000,000个数据用而二分搜索总是可以在20次或以内找到
  
example:
  n=100;
  count=1;
  while count<j:
      count=count*2;
      print('count',count)
  由于每次count乘以2之后，就距离n更近了一分。也就是说，有多少个2相乘后大于n，则会退出循环。由2x=n得到x=log2n。所以这个循环的时间复杂度为O(logn)。     
```
**O(n) 线性级**
```
循环结构
n=10
for i in range(n):
    print (i)  #n为10，输出10次 
```
**O(n^2) 平方级**
```
2层循环就是平方级,乘法运算也是平方级
x=4;
y=4;
for i in range(x):
    for ii in range(y):
        print(ii)
```
**O(c^n)指数级**
```

```
**O(n!)  阶乘**
```
旅行商问题
```